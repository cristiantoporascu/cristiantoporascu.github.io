<!DOCTYPE HTML>
<html>
	<head>
		<title>CIT - Cristian Ionut Toporascu</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<script src="../assets/js/jquery.min.js"></script>
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css" integrity="sha256-46qynGAkLSFpVbEBog43gvNhfrOj+BmwXdxFgVK/Kvc=" crossorigin="anonymous" />
	</head>
	<body>

		<!-- Header -->
		<header id="header">
			<div class="inner">
				<a href="index.html" class="logo">CIT DEV</a>
			</div>
		</header>

		<!-- Main -->
		<section id="main" >
			<div class="inner">
				<header class="major special">
					<h1>Zombie tutorial</h1>
					<ul class="actions">
						<li>
							<a href="https://github.coventry.ac.uk/304CR-1819JANMAY/TEACHING-MATERIALS" class="button alt">
								Source guides
							</a>
						</li>
					</ul>
				</header>
				<a href="#" class="image fit"><img src="../images/university304CR/zombie-tutorial/image0001.jpg" alt="main-zombietutorial" /></a>
				<div>
					<h5>Week 1</h5>

					<img src="../images/green.png" alt="green-task" />
					<p>
						For the first week I successfully managed to accomplish the tasks up to the red one.
						At the beginning of the Zombie Tutorial I prepared the repository and the project using Unity3D. As we developed a couple of projects in our
						first year with Unity, and myself throughout the time until now, setting up a 3D project was an easy task. As in the tutorial we were presented 
						to place in the scene just a few set of blocks. I decided to go with something that more complex, and therefore I ended up creating a labirinth.
					</p>
					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0002.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 1. Screenshot of the Scene setup</p>
						</span>
					</div>

					<p>
						After finishing setting up the scene, I started to import the standard assets, and set up in the scene the AIController and the PlayerController.
						Again, I was quite familiar with using the Standard Assets and the Navigation Mesh, as for one of my projects in my second year I made a Zombie Shooter type of
						game, which I had to integrate a navigation mesh and the AIThirdPersonController. That game can be seen at this <a href="../projects/giftmania.html" target="_blank">LINK</a>
					</p>

					<img src="../images/amber.png" alt="amber-task" />
					<p>
						In the tutorial, we were shown how to programmatically move the AI towards a specific target. This was explaining how to use a state machine in order to apply certain acctions
						to the AI. The script that was meant to be created was applied on the AIController. After finishing the required set of tasks from the zombie tutorial, I decided that there
						are a few ways which this could be improved. Which I will talk about in the final part of the Zombie Tutorial blog.
					</p>

					<img src="../images/red.png" alt="red-task" />
					<p>
						A really useful thing that I learned during the tutorials, was how to navigate in the scene using the Right Mouse Button. Which unfortunately I wasn't aware of before.
					</p>
				</div>

				<br/>
				<div>
					<h5>Week 2</h5>
					<img src="../images/green.png" alt="green-task" />
					<p>
						For the second week I succesfully managed to accomplish the tasks up to the red one.
						At the starting of this week, the first green task was to recreate the amber task from the previous week, that only if I have complited it already. But because I have already
						done that task and got a few ways to improve it, we were allowed to skip it.
					</p>

					<img src="../images/amber.png" alt="amber-task" />
					<p>
						As for the amber tasks, we had to make use of the free available characters from the Mixamo website. This website has a lot of free character models and animations. I was once
						again familiar with this tool, as in the second year we have been introduced to this so we could apply our learnings until then on characters that have the right topology and 
						bone structure for their animation.
					</p>
					<p>
						At this step I decided to go with a Soldier like 3DModel and a more detailed Zombie Character. My decision was made based on the fact that the tutorial is a Zombie Shooter tutorial.
					</p>
					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0003.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 2. Player 3D Model</p>
						</span>
					</div>

					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0004.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 3. AI Controller 3D Model</p>
						</span>
					</div>

					<p>
						In some cases, the model may look odd and lack its clothes and textures. Therefore, by following the tutorial I managed to fix this by going to the Materials tab and clicking 
						Extract Textures. I have created a new older for the textures and then I fixed all materials.
					</p>

					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0005.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 4. Fixed texture on the Player Controller Model</p>
						</span>
					</div>

					<p>
						After I fixed the model and all the textures, then I assigned the model to the PlayerController prefab in order to be able to use it in my game.
					</p>
					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0006.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 5. Player Controller prefab with the new 3DModel</p>
						</span>
					</div>

					<img src="../images/red.png" alt="red-task" />
					<p>
						In order to be able to animate the character when I was firing an event of punching, so that I would be able to kill the zombies, I had to create a state in which I would change the animation 
						from ideling or moving to the punching animation which I downloaded from Mixamo.
					</p>

					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0008.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 6. Set of downloaded animations</p>
						</span>
					</div>

					<p>
						Now that I have the animations, I have dragged the new animations in the Animator Controller that was already bound to the ThirdPersonController. I then created a boolean that would allow me 
						to programmatically access that boolean and change it so it would no when the new animation would have to be fired.
					</p>

					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0007.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 7. Animator and booleans for changins the animation</p>
						</span>
					</div>

					<p>
						The code that programatically was changing between the animations looks like the following:
					</p>

					<pre>
						<code>
public class PlayerController : MonoBehaviour
{
	private HitEnemy m_RightHand;
	private Animator m_Animator;

	// Start is called before the first frame update
	private void Start()
	{
		m_Animator = GetComponent<Animator>();
		m_RightHand = GetComponentInChildren<HitEnemy>();
	}

	// Update is called once per frame
	private void Update()
	{
		TriggerHit();
	}

	private bool CheckHitting()
	{
		bool isBoxing = Input.GetKey(KeyCode.Mouse0);
		m_Animator.SetBool("IsHittingBool", isBoxing);
		return isBoxing;
	}

	private void TriggerHit()
	{
		m_RightHand.SetAbleToHit(CheckHitting());
	}
}
						</code>
					</pre>
				</div>

				<br/>
				<div>
					<h5>Week 3</h5>
					<img src="../images/green.png" alt="green-task" />
					<p>
						Before we can add the chasing state to our state machine, we need to edit the wandering state and move towards the chasing state if we can see 
						the player. It is a good idea to put this in a function as we will need this again in the Chase and Dead states.
					</p>
					<pre>
						<code>
private void Update()
{
	switch (m_CurrentState)
	{
		case AiState.Wandering:
			Wandering();
			break;
		case AiState.Chasing:
			Chasing();
			break;
		case AiState.Dead:
			Die();
			break;
		case AiState.Summoned:
			Summoned();
			break;
	}
}
						</code>
					</pre>
					<p>
						For a higher code redability I decided to go with switch statement based on the state selected at a certain time, and then separate for each state
						on individual functions. I changed the tag on the players ThirdPersonController to "Player". This makes the player character easy to locate.
					</p>

					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0009.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 8. Set the ThirdPersonController tag</p>
						</span>
					</div>

					<p>
						Now that we can easily select the player, we can check whether the AI sees the player or not in order to be able to change the state from just wandering
						to chasing. For this part I merely used the code that was already provided in the Zombie Tutorial. I added additional states and changed the way the code for
						the chasing state and the wandering state worked so that it improves the AI and it helps to give a better gaming experience to the player.
					</p>
					<p>
						I will talk about the improvments done and the additions that I've brought to the AI in the final blog post.
					</p>

					<img src="../images/amber.png" alt="amber-task" />
					<p>
						To have an easier process of implementing the Death animation, not having to animate or match the animation with the actual death effect, we could implement a 
						ragdoll effect.
					</p>
					<p>
						The first step in this process is to apply the RagDool wizzard generator to create the collision boxes for our AI controller.
						We can find the ragdoll wizard on the zombie (Gameobject>3Dobject>ragdoll). This makes the work a lot easier as we don't need to manualy set up the parameters of
						each individual colision box or cilinder.
					</p>

					<div class="12u(small) 6u m-auto">
						<span class="image fit">
							<img src="../images/university304CR/zombie-tutorial/image0010.jpg" alt="main-week1-0002" />
							<p class="align-center">Fig 9. Ragdool generation and outcome</p>
						</span>
					</div>
					<p>
						Now that the AI has the collision boxes created, we need to set the rigid bodies to kinematic and disable the cylinders so that they won't collide with eachother and mess
						start reacting to eachother in the scene. We will reenable the them, when the AI will be killed by the player. We will reneable so that they would create the ragdool effect.
					</p>

					<p>
						Now we need just something to allow the player to kill the AI. We can do this by creating a collision box on one of the hands of the player. so that when it starts moving
						from the animation, it will move the collision box and then hit or pierce through the AI. After triggering a collision with the AI, we can then fire certain actions like killing the AI.
					</p>

					<pre>
						<code>
public class PlayerController : MonoBehaviour
{
	private HitEnemy m_RightHand;
	private Animator m_Animator;

	// Start is called before the first frame update
	private void Start()
	{
		m_Animator = GetComponent<Animator>();
		m_RightHand = GetComponentInChildren<HitEnemy>();
	}

	// Update is called once per frame
	private void Update()
	{
		TriggerHit();
	}

	private bool CheckHitting()
	{
		bool isBoxing = Input.GetKey(KeyCode.Mouse0);
		m_Animator.SetBool("IsHittingBool", isBoxing);
		return isBoxing;
	}

	private void TriggerHit()
	{
		m_RightHand.SetAbleToHit(CheckHitting());
	}
}

public class HitEnemy : MonoBehaviour
{
    private bool m_AbleToHit;

    // Start is called before the first frame update
    private void Start() {}

    // Update is called once per frame
    private void Update() {}

    private void OnTriggerEnter(Collider other)
    {
        if (m_AbleToHit && other.tag == "Zombie")
        {
            other.GetComponent<AITargetController>().Kill();
            m_AbleToHit = false;
        }
    }

    public void SetAbleToHit(bool newBool)
    {
        m_AbleToHit = newBool;
    }
}
						</code>
					</pre>

					<p>
						As we have the code now to fire the animation from the character and check for collisions with the AI, we can now create the functions that actually will enable
						the rigid bodies from the rag dool, and enable the collision boxes from the AI.
					</p>
					<pre>
						<code>
private void Die()
{
	m_SpawnEntitiesController.FinishedPatrollingById(m_CurrentWayPoint);

	GetComponent<Animator>().enabled = false; // Stop trying to animate myself
	GetComponent<NavMeshAgent>().enabled = false; // Stop trying to navigate
	GetComponent<AICharacterControl>().enabled = false; // Stop the AI

	GetComponent<Rigidbody>().isKinematic = true; // Make myself kinematic (ragdoll)

	foreach (Rigidbody rbody in GetComponentsInChildren<Rigidbody>())
	{
		rbody.isKinematic = false;
	}

	foreach (Collider col in GetComponentsInChildren<Collider>())
	{
		col.enabled = true;
	}

	Destroy(gameObject, 2); // Remove myself from the game after timeout
}
						</code>
					</pre>

					<img src="../images/red.png" alt="red-task" />
					<p>
						I decided for the latest part just to put plane materials on my objects, as I wanted to focus my attention on improving the AI, and not texturing objects.
					</p>
				</div>

				<br/>
				<div>
					<h5>Week 4</h5>
					<img src="../images/green.png" alt="green-task" />
					<p>
						We now have a functioning game. However, once the player kills the AI that's kind of it. Now in order to improve the playability and game factor of the game 
						we should be able to spawn more AIs after one dies. We are going to achieve this by attaching a script that checks how many are in play at a certain time.

					</p>
					<p>
						I found some ways to improve this which I am going to talk about in the final blog post, for now we will stick to the way it was done in the zombie tutorial.
						First of all, create a new empty gameobject called something like "Zombies". We will "spawn" our zombies here to keep the editor clutter free.
					</p>

					<p>
						For the script we will disable the prefab of the AI attached so that the main object that we make copies of never gets destroyed.
						We will also store an array of waypoints so that we know where the AI can spawn. These can be different also from the waypoints making
						another set of spawn points.
					</p>

					<pre>
						<code>
public class SpawnZombies : MonoBehaviour {

	public int numberOfZombies = 5;//How many zombies do we want in our game?

	private GameObject[] allWaypoints;// list to store all waypoints
	private GameObject zombiePrefab;

	// Use this for initialization
	void Start () {
		allWaypoints = GameObject.FindGameObjectsWithTag("Waypoint");
		zombiePrefab = GameObject.FindGameObjectWithTag("Zombie");
		zombiePrefab.SetActive(false);
	}
						</code>
					</pre>

					<p>
						In the update we will want to check how many zombies we have and add zombies until the required number has been reached.
					</p>

					<pre>
						<code>
	void Update () {
		//using a counter of the amount of zombies we have at the moment. We want to avoid having to do GameObject.find too many times
		int nrZombiesExist = GameObject.FindGameObjectsWithTag("Zombie").Length;
		while (nrZombiesExist < numberOfZombies){

			//instatiates a copy of zombiePrefab. I places it at the position of one of the waypoints (randomly picks an index in the waypoint array). It gives it a new rotation and adds the object that this script is attached to as parent
			Instantiate(zombiePrefab, allWaypoints[Random.Range(0, allWaypoints.Length - 1)].transform.position, new Quaternion(), transform).SetActive(true);
			//count them manually instead of calling FindGameObjectsWithTag every time
			nrZombiesExist++;
		}

	}
}
						</code>
					</pre>

					<img src="../images/amber.png" alt="amber-task" />
					<p>
						I will talk about further improvments that I've done in the final blog post.
					</p>
				</div>

				<br/>
				<div>
					<h5>Final project improvments</h5>
					<p>
						Placeholder
					</p>
				</div>
			</div>
		</section>

		<!-- Footer -->
		<section id="footer">
			<div class="inner clearfix">
				<div class="copyright float-left">
					&copy; CITDevelopment 2020
				</div>
				<div class="float-right">
					<ul class="icons">
						<li>
							<a href="mailto:toporascu.cristian@gmail.com" class="icon"><i class="fas fa-envelope-square fa-2x"></i></a>
						</li>
						<li>
							<a href="https://github.com/toporasc" class="icon"><i class="fab fa-github-square fa-2x"></i></a>
						</li>
						<li>
							<a href="https://www.linkedin.com/in/cristian-ionut" class="icon"><i class="fab fa-linkedin fa-2x"></i></a>
						</li>
					</ul>
				</div>
			</div>
		</section>

		<!-- Scripts -->
		<script src="../assets/js/skel.min.js"></script>
		<script src="../assets/js/util.js"></script>
		<script src="../assets/js/main.js"></script>

	</body>
</html>